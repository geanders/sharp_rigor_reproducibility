---
title: "Lab---Functional Programming"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

## Functional Programming

In this lab, we will practice using functional programming to simplify the task
of reading in data from different files and cleaning it. We will create a
function that encapsulates the steps that are currently in the script to read in
and clean the data, so it's ready for our analysis (filtering to a certain
property and type of animal and counting the number of call per month). 

We'll add this, in the script, to the function that we developed in the lecture
right before this lab, and we'll look at how using functions can help us
encapsulate tasks within the code in a way that lets us reuse the code without
copying and pasting it. In a later lab, we'll add to these ideas by exploring
how using the `map` function in the `purrr` package can help simplify the
process.

## Setting up for this lab

To start this lab, make sure that you have a copy of the script we ended up with at 
the end of the last lab. If you created a different version, you're welcome to use 
that instead, but keep in mind that you may need to adjust the example code given in 
this lab to accommodate differences in your version (for example, different names you 
selected for objects or columns). 

As a reminder, here's the code we ended up with at the end of the last lab: 

```{r include = FALSE}
# Load required libraries
library(readr)
library(janitor)
library(dplyr)
library(lubridate)

# Read in data and clean column names
man_animal_resp <- read_csv("../data/Manhattan_animal_response.csv") %>% 
  clean_names() %>% 
  rename(datetime_call = date_and_time_of_initial_call)

# Filter to data on reptiles and amphibians in Central Park
man_animal_resp <- man_animal_resp %>% 
  filter(property == "Central Park") %>%  
  filter(animal_class == "Terrestrial Reptile or Amphibian")

# Filter to years with data covering the full year (2018 and 2021 do not)
man_animal_resp <- man_animal_resp %>% 
  mutate(datetime_call = mdy_hms(datetime_call), 
         call_year = year(datetime_call)) %>% 
  filter(call_year %in% c(2019, 2020))

# Count number of response calls per month
man_animal_resp <- man_animal_resp %>% 
  mutate(call_month = month(datetime_call, 
                            label = TRUE, 
                            abbr = FALSE))
  
monthly_man_animal_response <- man_animal_resp %>% 
  count(.wt = call_month)
monthly_man_animal_response
```

In the lecture before this class, we covered how to create a function that counts the 
number of calls per month (we'll work on improving this function in a later lab). 
You'll also find it use to have the code that defines this function handy. It is:

```{r}
# To run this function, you will need to have the following packages installed:
# dplyr, tibble
count_monthly_calls <- function(call_data) {
  monthly_calls <- call_data %>% 
    dplyr::count(.wt = call_month) %>% 
    dplyr::rename(month = .wt)
  
  all_months <- tibble::tibble(month = c("January", "February", "March", "April", 
                                         "May", "June", "July", "August", "September", 
                                         "October", "November", "December"), 
                               order = 1:12)
  
  monthly_calls <- dplyr::full_join(monthly_calls, all_months, by = "month") %>% 
    dplyr::mutate(n = if_else(is.na(n), 0, n)) %>% 
    dplyr::arrange(order) %>% 
    dplyr::select(-order)
  
  return(monthly_calls)
}
```

In the lecture, we also looked at how we could edit the script to use this function. 
Here's the version of the script that includes the function:

```{r eval = FALSE}
# Load required libraries
library(readr)
library(janitor)
library(dplyr)
library(lubridate)

## Define functions ######################################################################

# To run this function, you will need to have the following packages installed:
# dplyr, tibble
count_monthly_calls <- function(call_data) {
  monthly_calls <- call_data %>% 
    dplyr::count(.wt = call_month) %>% 
    dplyr::rename(month = .wt)
  
  all_months <- tibble::tibble(month = c("January", "February", "March", "April", 
                                         "May", "June", "July", "August", "September", 
                                         "October", "November", "December"), 
                               order = 1:12)
  
  monthly_calls <- dplyr::full_join(monthly_calls, all_months, by = "month") %>% 
    dplyr::mutate(n = if_else(is.na(n), 0, n)) %>% 
    dplyr::arrange(order) %>% 
    dplyr::select(-order)
  
  return(monthly_calls)
}

## Analysis #####################################################################

# Read in data and clean column names
man_animal_resp <- read_csv("../data/Manhattan_animal_response.csv") %>% 
  clean_names() %>% 
  rename(datetime_call = date_and_time_of_initial_call)

# Filter to data on reptiles and amphibians in Central Park
man_animal_resp <- man_animal_resp %>% 
  filter(property == "Central Park") %>%  
  filter(animal_class == "Terrestrial Reptile or Amphibian")

# Filter to years with data covering the full year (2018 and 2021 do not)
man_animal_resp <- man_animal_resp %>% 
  mutate(datetime_call = mdy_hms(datetime_call), 
         call_year = year(datetime_call)) %>% 
  filter(call_year %in% c(2019, 2020))

# Count number of response calls per month
man_animal_resp <- man_animal_resp %>% 
  mutate(call_month = month(datetime_call, 
                            label = TRUE, 
                            abbr = FALSE)) 
monthly_man_animal_response <- count_monthly_calls(man_animal_resp) 
monthly_man_animal_response
```

Notice how this script continues to use blocking to reinforce separate sections of the code, 
now both in terms of tasks that are being done and also in terms of separating the 
function definitions from the analysis script. Also, you may have noticed that we needed
to rearrange some of the code so that we could add in the column `call_month` before 
we run the new function, since the function relies on having that column in the data. 

## Writing a function

Now it's your turn to try writing a function. Let's write a function the
encapsulates all the steps of reading in and cleaning the data. We'll then edit the
script to incorporate this function. 

The first step is to go through the code script and identify all the steps that you 
are doing that are related to reading in and cleaning the data. 

Those steps are: 

- Read data from the CSV files
- Clean the column names (this includes a first step of general cleaning and then 
some more specialized cleaning to treat a case that wasn't handled in the general 
step)
- Convert the column on the dates to a date-time class, so you can work with it in 
later code as a date-time object

There are some other steps you might want to consider, as well, depending on how 
you plan to look at the data once you read it in. Some other steps you could consider
adding to this function are: 

- Removing columns that you aren't planning to use in your analysis (There are a lot
of columns in this dataset, and it can make it easier to work on your target problem
if you remove those from your working dataframe in R. Remember that this won't 
delete the columns from the data saved in the CSV, so that data will always be there
if you need to go back and add them.)
- Add columns for the month and year (These are new columns that you use in some of
your analysis, so it may make sense to create these as you read in the data. These steps
are easy to do in the code script, too, once you've read in the data, but if you know
you'll want them in your data, you could extract that step to the reading / cleaning 
process.)
- Filter to full years of call data (in this case, 2019 and 2020)

We'll first write a function that encapsulates the steps we know we want to put
in the function, then we'll look at how we could add these additional pieces.
Let's start by looking at the script to see which parts we want to pull out
(I've added comments on those in the script):

```{r}
# Load required libraries
library(readr)
library(janitor)
library(dplyr)
library(lubridate)

# Read in data and clean column names
man_animal_resp <- read_csv("../data/Manhattan_animal_response.csv") %>% # Put in function
  clean_names() %>%                                                      # Put in function
  rename(datetime_call = date_and_time_of_initial_call)# Put in function

# Filter to data on reptiles and amphibians in Central Park
man_animal_resp <- man_animal_resp %>% 
  filter(property == "Central Park") %>%  
  filter(animal_class == "Terrestrial Reptile or Amphibian")

# Filter to years with data covering the full year (2018 and 2021 do not)
man_animal_resp <- man_animal_resp %>% 
  mutate(datetime_call = mdy_hms(datetime_call),                         # Put in function
         call_year = year(datetime_call)) %>%                            # Maybe put in function
  filter(call_year %in% c(2019, 2020))                                   # Maybe put in function

# Count number of response calls per month
monthly_man_animal_response <- man_animal_resp %>% 
  mutate(call_month = month(datetime_call,                               # Maybe put in function
                            label = TRUE, 
                            abbr = FALSE)) %>% 
  count(.wt = call_month)
monthly_man_animal_response
```

The following code chunk defines a function that encapsulates the parts we know
we want to go in the function. Take a look at how this compares to the code in the 
script above. Hopefully you notice that a lot of the code is very similar to the code 
in the script. The key difference is that we're defining a parameter with the filename 
(`file`) and then using that as an input to the next steps, rather than a character string
with a single filename as we did in the script. Also, the function is using `return` to 
specify what we'd like to get out of the function once it's run. 

```{r}
read_and_clean_call_data <- function(file){
  
  # Read in data and clean column names
  call_data <- read_csv(file = file) %>% 
    clean_names() %>% 
    rename(datetime_call = date_and_time_of_initial_call)
  
  # Convert date-time column to appropriate data type
  call_data <- call_data %>% 
    mutate(datetime_call = mdy_hms(datetime_call))
  
  return(call_data)
}
```

Once you have run this code---which defines the function in your R session---you can 
try it out: 

```{r}
manhattan_calls <- read_and_clean_call_data(file = "../data/Manhattan_animal_response.csv")

manhattan_calls
```

Some notes on this process: 

- You get to pick the name for the function, as well as the name for each parameter
in the function. For naming parameters, it can be helpful if you use similar names to 
those used in more general functions. For example, the heart of this new function is 
to read in data from a CSV. We'll need a parameter that lists the name of the file that
you want to read in. It's helpful to use the same parameter name as the one used by 
the general function `read_csv`, which is `file`. 
- You can include code comments within the function

Now let's add the option steps (adding columns for the month and year of the call, 
removing all the columns we're not planning interested in for our research question): 

```{r}
read_and_clean_call_data <- function(file){
  
  # Read in data and clean column names
  call_data <- read_csv(file = file) %>% 
    clean_names() %>% 
    rename(datetime_call = date_and_time_of_initial_call)
  
  # Limit to columns we'll need for our research question
  call_data <- call_data %>% 
    select(datetime_call, property, location, species_description, 
           animal_class, final_ranger_action)
  
  call_data <- call_data %>% 
    # Convert date-time column to appropriate data type
    mutate(datetime_call = mdy_hms(datetime_call)) %>%
    # Add columns for the year and month of the call
    mutate(call_year = year(datetime_call),
           call_month = month(datetime_call,
                              label = TRUE, 
                              abbr = FALSE)) 
  
  return(call_data)
}
```

Now, let's add an optional part of the function, an optional filter to the years with data
year-round: 

```{r}
read_and_clean_call_data <- function(file, remove_partial_years = FALSE){
  
  # Read in data and clean column names
  call_data <- read_csv(file = file) %>% 
    clean_names() %>% 
    rename(datetime_call = date_and_time_of_initial_call)
  
  # Limit to columns we'll need for our research question
  call_data <- call_data %>% 
    select(datetime_call, property, location, species_description, 
           animal_class, final_ranger_action)
  
  call_data <- call_data %>% 
    # Convert date-time column to appropriate data type
    mutate(datetime_call = mdy_hms(datetime_call)) %>%
    # Add columns for the year and month of the call
    mutate(call_year = year(datetime_call),
           call_month = month(datetime_call,
                              label = TRUE, 
                              abbr = FALSE)) 
  
  if(remove_partial_years == TRUE) {
    call_data <- call_data %>% 
      filter(call_year %in% c(2019, 2020))
  }
  
  return(call_data)
}
```

Again, once you've run this code to update your function definition in your R session, 
you can try the function on an example file: 

```{r}
manhattan_calls <- read_and_clean_call_data(file = "../data/Manhattan_animal_response.csv")

manhattan_calls

manhattan_full_years <- read_and_clean_call_data(file = "../data/Manhattan_animal_response.csv",
                                                 remove_partial_years = TRUE)
manhattan_full_years
```

Next, it's helpful if we add some code that clarifies which package each function
in the code comes from. This way, the function can run as long as the user has
installed that package, whether or not the the user has remember to load the package in their
R session. You can all add comments to let the user know which packages they'll need
to have installed to run the function. 

```{r} 
# To run this function, you will need to have the following functions installed:
# readr, janitor, dplyr, lubridate
read_and_clean_call_data <- function(file, remove_partial_years = FALSE){
  
  # Read in data and clean column names
  call_data <- readr::read_csv(file = file) %>% 
    janitor::clean_names() %>% 
    dplyr::rename(datetime_call = date_and_time_of_initial_call)
  
  # Limit to columns we'll need for our research question
  call_data <- call_data %>% 
    dplyr::select(datetime_call, property, location, species_description, 
                  animal_class, final_ranger_action)
  
  call_data <- call_data %>% 
    # Convert date-time column to appropriate data type
    dplyr::mutate(datetime_call = lubridate::mdy_hms(datetime_call)) %>%
    # Add columns for the year and month of the call
    dplyr::mutate(call_year = lubridate::year(datetime_call),
                  call_month = lubridate::month(datetime_call,
                                                label = TRUE, 
                                                abbr = FALSE)) 
  
  if(remove_partial_years == TRUE) {
    call_data <- call_data %>% 
      dplyr::filter(call_year %in% c(2019, 2020))
  }
  
  return(call_data)
}
```

Now you can edit your script to use this function: 

```{r}
# Load required libraries
library(readr)
library(janitor)
library(dplyr)
library(lubridate)

## Define functions ######################################################################

# To run this function, you will need to have the following functions installed:
# readr, janitor, dplyr, lubridate
read_and_clean_call_data <- function(file, remove_partial_years = FALSE){
  
  # Read in data and clean column names
  call_data <- readr::read_csv(file = file) %>% 
    janitor::clean_names() %>% 
    dplyr::rename(datetime_call = date_and_time_of_initial_call)
  
  # Limit to columns we'll need for our research question
  call_data <- call_data %>% 
    dplyr::select(datetime_call, property, location, species_description, 
                  animal_class, final_ranger_action)
  
  call_data <- call_data %>% 
    # Convert date-time column to appropriate data type
    dplyr::mutate(datetime_call = lubridate::mdy_hms(datetime_call)) %>%
    # Add columns for the year and month of the call
    dplyr::mutate(call_year = lubridate::year(datetime_call),
                  call_month = lubridate::month(datetime_call,
                                                label = TRUE, 
                                                abbr = FALSE)) 
  
  if(remove_partial_years == TRUE) {
    call_data <- call_data %>% 
      dplyr::filter(call_year %in% c(2019, 2020))
  }
  
  return(call_data)
}

# To run this function, you will need to have the following packages installed:
# dplyr, tibble
count_monthly_calls <- function(call_data) {
  monthly_calls <- call_data %>% 
    dplyr::count(.wt = call_month) %>% 
    dplyr::rename(month = .wt)
  
  all_months <- tibble::tibble(month = c("January", "February", "March", "April", 
                                         "May", "June", "July", "August", "September", 
                                         "October", "November", "December"), 
                               order = 1:12)
  
  monthly_calls <- dplyr::full_join(monthly_calls, all_months, by = "month") %>% 
    dplyr::mutate(n = if_else(is.na(n), 0, n)) %>% 
    dplyr::arrange(order) %>% 
    dplyr::select(-order)
  
  return(monthly_calls)
}

## Analysis #####################################################################

# Read in data and clean data
man_animal_resp <- read_and_clean_call_data(file = "../data/Manhattan_animal_response.csv", 
                                            remove_partial_years = TRUE)

# Filter to data on reptiles and amphibians in Central Park
man_animal_resp <- man_animal_resp %>% 
  filter(property == "Central Park") %>%  
  filter(animal_class == "Terrestrial Reptile or Amphibian")

# Count number of response calls per month
monthly_man_animal_response <- count_monthly_calls(man_animal_resp) 
monthly_man_animal_response
```


