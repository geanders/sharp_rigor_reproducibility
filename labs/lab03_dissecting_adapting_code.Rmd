---
title: "Lab-Finding and Adapting Code"
author: "Brooke Anderson"
date: "2023-07-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, messages = FALSE, warnings = FALSE)
```

To prepare for this lab, make sure that you've run the final script from the last 
lab in your current R session. As a reminder, that code is: 

```{r include = FALSE}
# Load required libraries
library(readr)
library(janitor)
library(dplyr)
library(lubridate)

## Define functions ######################################################################

# To run this function, you will need to have the following functions installed:
# readr, janitor, dplyr, lubridate
read_and_clean_call_data <- function(file, remove_partial_years = FALSE){
  
  # Read in data and clean column names
  call_data <- readr::read_csv(file = file) %>% 
    janitor::clean_names() %>% 
    dplyr::rename(datetime_call = date_and_time_of_initial_call)
  
  # Limit to columns we'll need for our research question
  call_data <- call_data %>% 
    dplyr::select(datetime_call, property, location, species_description, 
                  animal_class, final_ranger_action)
  
  call_data <- call_data %>% 
    # Convert date-time column to appropriate data type
    dplyr::mutate(datetime_call = lubridate::mdy_hms(datetime_call)) %>%
    # Add columns for the year and month of the call
    dplyr::mutate(call_year = lubridate::year(datetime_call),
                  call_month = lubridate::month(datetime_call,
                                                label = TRUE, 
                                                abbr = FALSE)) 
  
  if(remove_partial_years == TRUE) {
    call_data <- call_data %>% 
      dplyr::filter(call_year %in% c(2019, 2020))
  }
  
  return(call_data)
}

# To run this function, you will need to have the following packages installed:
# dplyr, tibble
count_monthly_calls <- function(call_data) {
  monthly_calls <- call_data %>% 
    dplyr::count(.wt = call_month) %>% 
    dplyr::rename(month = .wt)
  
  all_months <- tibble::tibble(month = c("January", "February", "March", "April", 
                                         "May", "June", "July", "August", "September", 
                                         "October", "November", "December"), 
                               order = 1:12)
  
  monthly_calls <- dplyr::full_join(monthly_calls, all_months, by = "month") %>% 
    dplyr::mutate(n = if_else(is.na(n), 0, n)) %>% 
    dplyr::arrange(order) %>% 
    dplyr::select(-order)
  
  return(monthly_calls)
}

## Analysis #####################################################################

# Read in data and clean data
man_animal_resp <- read_and_clean_call_data(file = "../data/Manhattan_animal_response.csv", 
                                            remove_partial_years = TRUE)

# Filter to data on reptiles and amphibians in Central Park
man_animal_resp <- man_animal_resp %>% 
  filter(property == "Central Park") %>%  
  filter(animal_class == "Terrestrial Reptile or Amphibian")

# Count number of response calls per month
monthly_man_animal_response <- count_monthly_calls(man_animal_resp) 
monthly_man_animal_response
```

In that last lab, one of the tasks that we did was create a way to get a summary
of counts of calls by months that included rows with zeros. We ultimate did that
using a function we created called `count_monthly_calls`. 

This function seems to work pretty well to complete that task. However, there are a 
couple of issues with the way we've talked that problem. First, the logic of the 
code isn't as clearly linked to the logic of the task as we might want (in other 
words, the solution is currently a bit of a kludge). The code will be easier to 
understand and maintain if we can find a better way to link its logic with the logic 
of the task. 

Second, while the code works well for the table we created, once we try to plot the
data, we might not be completely happy with how it works. Let's take a look at 
plotting the monthly counts as a bar chart: 

```{r}
library(ggplot2)
monthly_man_animal_response %>% 
  ggplot(aes(x = n, y = month)) + 
  geom_col()
```

This creates a bar chart, but take a look at the y-axis: the months are in alphabetical
order. The visualization would be much better if the months show up in the order they 
occur in the year. This would help to identify seasonal patterns.

Let's try to search for some examples of how to do this task. We'll dissect the code 
examples we can find and adapt them to our current task. Our aim will be to find a 
solution that (1) has code with logic that aligns better to the logic of the task and
(2) preserves the order of the months so that they show up in their order by year 
when we plot the results. 

## Finding example code

We'll start by trying to find some advice and examples of how we can solve the task. 
A reasonable Google search to start with is something like, "R count rows by group include
levels with no counts". Here are some promising leads that come up with that search:

- https://stackoverflow.com/questions/42017926/r-group-by-show-count-of-all-factor-levels-even-when-zero-dplyr
- https://community.rstudio.com/t/dplyr-count-include-a-0-for-factor-levels-not-in-the-data/26462/4 
- https://dplyr.tidyverse.org/reference/count.html, specifically the part in the 
Examples that says "When factors are involved, `.drop = FALSE` can be used to retain factor
levels that don't appear in the data"
- https://kieranhealy.org/blog/archives/2018/11/19/zero-counts-in-dplyr/

We won't have the chance to work through all of these in the lab today. Let's try out 
the first two. We'll start by dissect the examples to decide which one we want to adapt
for our task (or if we want to combine elements of both). 

## Dissecting code

Let's start by looking at the Stack Overflow thread (https://stackoverflow.com/questions/42017926/r-group-by-show-count-of-all-factor-levels-even-when-zero-dplyr). The example code in the question is: 

```{r eval = FALSE}
set.seed(1)
dat <- data.frame(ID = sample(letters,50,rep=TRUE))
dat %>% 
  group_by(ID) %>%
  summarise(no_rows = length(ID))
```

This is followed by the question: 

> "I have the above code which creates a random sample of letters. However can I make the summarised output show all count levels even when there is zero.

> When I run the above code sometimes I get 20 rows and sometimes I get 25, etc. I want this to return 26 rows every time."

Let's try out the example code and see what happens. The code first sets a seed:

```{r}
set.seed(1)
```

If you aren't familiar with this function, open its helpfile to see more on what
it's doing (which you can do by running `?set.seed` at the console). If this
isn't helpful (the helpfile in this case uses pretty technical language), you
can instead try googling to find out more. Essentially, this function call
allows you to ensure that any step that uses random number generation (like
`sample`, which should pull a new sample of your vector every time you use it)
will instead always result in the same "random" sample. This is often used in
questions about code examples that include random number generation, because it
ensures that everyone who runs the code will get the same results.

The next line creates a dataframe: 

```{r}
dat <- data.frame(ID = sample(letters,50,rep=TRUE))
```

You can check to see what the created dataframe looks like: 

```{r}
head(dat)
```

You can see that this has created a dataframe with a single column called "ID". This column
has a letter in it for each row. This column was created with a piece of code that 
was embedded in the line we just looked at, specifically, 

```{r eval = FALSE}
sample(letters,50,rep=TRUE)
```

Let's dissect this to see what it's doing. It's often helpful to start from the inside
and work out. At the inside of this function is a call to `letters`. This looks like
an object, but the person who posted the question doesn't have any code that defines
this object before we use it. Let's check out that object to see what's going on: 

```{r}
letters
```

This seems to be an object with the 26 lowercase letters in the Roman alphabet. It must
be an object that comes with base R, because we haven't done anything to create the object. 
If it is, it will probably have a helpfile, so let's try to pull that up with `?letters`. 

That call pulls up a helpfile that confirms that this is a built-in constant that comes
with base R. When people write code questions, they'll often use something like these
built-in constants, or a dataframe that comes with a package that the question uses, 
because that helps set up the example code in the question as quickly as possible.

Now let's look at how that object's being used to make the column in the example 
dataframe: 

```{r}
sample(letters,50,rep=TRUE)
```

This call looks like it's pulling a sample from `letters`, so we end up with a sample 
of 50 lowercase letters. If you're not familiar with the `sample` function, you can 
pull up the help function for `sample`. 

From that helpfile, you can confirm that the `sample` function takes a sample from 
a vector (in this case, from the `letters` vector). We can also use that helpfile to
figure out what the parameters are doing (the `50` and the `rep=TRUE`). The `50` is 
put in the second position of the function call, so it will be the value given for 
the second argument of the function call. Based on the Usage section of the helpfile, 
that argument is `size`. If you look for `size` under Arguments, you can see that this
argument sets how many values to sample from the vector. This makes sense: we saw when
we ran the code that it's sampling 50 values from the set of letters. 

The other argument in the call in the example is `rep=TRUE`. If we look through
the Arguments section, there is not an argument called "rep". However, there is
one that starts with "rep", the argument `replace`. It turns out that you can
use just the first few letters of an argument when you call a function. This can
be messy, though, because it only works if there's only one argument that starts
with those letters. Also, it can make it harder to understand what the call is
doing ("replace" is clearer, for example, than "rep"). If we look at the
Arguments section, we can see that `replace` is used to say whether the object
should be sampled with replacement. In other words, in our example should we be
able to have more than one copies of the same letter in the vector we're
creating? For our example, we have to allow replacement in the sampling, because 
there are only 26 letters in `letters` and we want to make a vector that has
50 values, so there will have to be some letters that show up more than once. 

Now we can revisit how this is creating the example dataframe: 

```{r}
set.seed(1)
dat <- data.frame(ID = sample(letters,50,rep=TRUE))
```

Again, if you aren't clear on how the `data.frame` function works, or what `ID = `
is doing in this call, you can use helpfiles to help figure it out. 

We've now determined that the example code has created a simple dataframe with a single
column, called "ID", that has a sample of 50 letters, where some letters show up 
more than once and some may never show up. Since it includes random number generation 
(in `sample`), the exact letters that show up would change if we didn't set the seed, 
but if we set the same seed right before we run the function call, we'll get the same
dataframe of `dat` as the person who posted the question did. 

Now let's look at the next part of the code: 

```{r eval = FALSE}
dat %>% 
  group_by(ID) %>%
  summarise(no_rows = length(ID))
```

This looks like it's very similar to what we're trying to do when we run the `count`
function in our code. In fact, if we look up the help file for `count` and read the 
Description, it states that: 

> "`df %>% count(a, b)` is roughly equivalent to `df %>% group_by(a, b) %>% summarise(n = n())`"

If you wanted, you could dissect this code the same way we did with earlier code
(for example, look up helpfiles for `length`, `summarise`, and `group_by`). For
now, let's see the output of the example code:

```{r}
dat %>% 
  group_by(ID) %>%
  summarise(no_rows = length(ID))
```

We can see that this is counting up the number of times that each letter shows up 
in the `ID` column in the dataframe. If you look through the data (and set the same 
seed as the example), you can see that it's missing some of the letters, including
"l" and "p".

This is good---we have found an answered question that tackles the same task we're 
trying to do. In this case, we're looking at a dataframe with a column that has 
the possibility of taking 26 different values (the 26 letters), but has some that didn't
show up in the sample, and these are missed when counting the values. This is 
analogous to our task---we have a column (`call_month`) that can in theory take 
12 different values (the months and then year), but in practice sometimes no calls are
reported in one of those months, and we would like the summary to still list those months
with a count of 0 rather than exclude those months from the summary. 

Now let's look at the top-ranked solutions that was provided (the solution that starts, 
"In the accepted answer by akrun ..."). It repeats the set-up of the `dat` dataframe and
then has the following code: 

```{r eval = FALSE}
dat %>%
  mutate(ID = factor(ID, levels = letters)) %>%
  count(ID, name = "no_rows", .drop = F) %>%
  print.data.frame()
```

Let's work out way through this code to understand how it works. Then we'll see 
if we can apply it to our question. 

This piece of code is a pipeline---it uses the pipe symbol (`%>%`) to chain together
several calls, sending the output from one as input into the next. This type of 
pipeline can be a great way to include code in your script, as we discussed in the
lecture on editing code. However, when you dissect code that's in a pipeline like 
this, you'll want to tease it apart so you can understand each step. 

Let's take the pipeline apart and look at it piece by piece. Let's start by looking
at only the first function call in the pipeline. The dataframe `dat` is piped into 
a `mutate` call, and a `factor` call is nested within the `mutate`. 

```{r eval = FALSE}
dat %>%
  mutate(ID = factor(ID, levels = letters))
```

Let's work from the inside out for the function call. The innermose call is to `factor`. 
Let's use the helpful to see what that does (`?factor`).

Based on the helpfile, the `factor` function will input a vector and change it to a 
factor. This is one of the classes of data that values in a vector can have in R 
(others include numeric, character strings, dates, date-times, and so on). If you 
aren't familiar with factors and how they work, there is a chapter in **R for Data 
Science** that you might find very helpful (https://r4ds.had.co.nz/factors.html). 

Factors are very helpful when you have a value that can only take one of a set of 
values. As one example, the original data for the animal response calls includes 
a variable with the animal's age, which can only be "Juvenile" or "Adult". In the
StackOverflow example we're looking at here, the values in the sample of letters can
only be one of the 26 lowercase letters in the Roman alphabet. In the task we're 
trying to write a function for, the variable can only take one of twelve values, 
the twelve months in the year. 

It is a good strategy, when dissecting code, to look carefully at the object 
that the function call operates on, carefully comparing what it looks like before
and after the function call. Here, the larger function call is `mutate`, which 
operates on the `dat` object. However, right now we're focusing on the call of 
the `factor` function, which is nested inside the `mutate`. That call operates
on one of the columns in the `dat` dataframe, specifically the `ID` column. 

It may be helpful if we zoom in to look at just that column, before and after
the `factor` call. We can extract the column either with the `$` operator (e.g., 
`dat$ID`) or with the `pull` function from `dplyr`. I'll use the second so you can
try that, if you're not familiar with it:

```{r}
# Look at the ID column from dat before we run the factor call
dat %>% 
  pull(ID) 

# Look at the ID column from dat after we run the factor call
dat %>% 
  pull(ID) %>% 
  factor(levels = letters)
```

Before the `factor` call, this column is a character string, with each value in quotation
marks (you could also use the `class` function to check that the column is stored 
as character strings at this point). After we run the call, the column is a factor 
class. You can tell that because the quotation marks are gone, and also R records it 
not only with the values for each element of the vector, but also includes a "Levels" 
section, where it lists all the values that the factor is allowed to have. 

This is great, because it establishes a "memory" of all the possible values of the factor. 
This is what R can draw on to include values with counts of zero when we want to 
summarize the counts later. 

Let's see how this function call was able to provide the information about the levels---notice
that the "Levels" include letters (like "m") that aren't included as values in the 
vector itself. 

The `factor` call includes one argument in addition to the vector that we're asking it 
to change to a factor. Specifically, it includes the argument `levels = letters`. We 
already know that `letters` is a built-in vector in R that gives the 26 lowercase letters. 
To figure out the `levels` part, we can take a look at the helpfile for `factor` and 
scroll down to the Arguments section. Under `levels`, it says: 

> "`levels`: an optional vector of the unique values (as character strings) that x might have taken. The default is the unique set of values taken by as.character(x), sorted into increasing order of x. Note that this set can be specified as smaller than sort(unique(x))."

Based on this, the function call is using the built-it `letters` vector to tell R which 
set of values the new factor could take, forcing it to include ones like "m" that aren't
listed in the data but are possible. This also says that, if we don't include this, 
the levels will be set as the unique values in the data---in other words, if we didn't 
include this part, the factor levels would not have included missing but possible values
like "m". 

This seems like it will be very helpful with our task---we want R to "remember" that 
animal calls could be reported in any of the twelve months, and then provide a 0 value
for months without calls, rather than dropping them out from the summary. 

Now that we know what the `factor` call is doing, it's pretty straightforward to 
figure out what the `mutate` call that it's nested in is doing. The `mutate` function 
is typically used to create a new column or change an existing one. In this case, 
it's changing the `ID` column in the `dat` dataframe, converting it from a character
class to a factor class, where the factor has as levels the 26 lowercase letters in the 
`letters` vector. Again, we can run the object that's being operated on (`dat` in this
case) before and after the function call to compare and make sure we understand
what's going on:

```{r}
# Check the dat dataframe before the mutate call
dat

# Check the dat dataframe after the mutate call
dat %>%
  mutate(ID = factor(ID, levels = letters))
```

In the handout for this lab, you might not see much of a difference between these two 
printouts. Sometimes, it can be subtle to identify a change in the class of the object.

However, if you open the RMarkdown file for this lab and run the code in that, or 
run it from a console, you should be able to see that it prints out the class of the column
right below the column name. From this annotation, you can see that the column is 
changing from a character class (`<chr>`) to a factor class (`<fctr>`). You can also use 
the `summary` function to get information about all columns in a dataframe, including
their class of data: 

```{r}
# Check the dat dataframe before the mutate call
dat %>% 
  summary()

# Check the dat dataframe after the mutate call
dat %>%
  mutate(ID = factor(ID, levels = letters)) %>% 
  summary()
```

Now let's move to the next step in the pipeline from the example solution: 

```{r}
dat %>%
  mutate(ID = factor(ID, levels = letters)) %>%
  count(ID, name = "no_rows", .drop = F)
```

This is using a `count` function. We already know, from our original function, that 
this function will count up the number observations in each group within a dataset. 
This call is using some arguments that we didn't use in our earlier code, though. 
Specifically, it uses `name = "no_rows"` and `.drop = F`. Let's figure out what 
each of those are doing before we try to adapt this code for our own task. 

First, let's look at `names = "no_rows"`. Let's start by comparing the output when 
we include this argument versus when we leave it out: 

```{r}
# Check count call output when including `name = "no_rows"`
dat %>%
  mutate(ID = factor(ID, levels = letters)) %>%
  count(ID, name = "no_rows", .drop = F)

# Check count call output when excluding `name = "no_rows"`
dat %>%
  mutate(ID = factor(ID, levels = letters)) %>%
  count(ID, .drop = F)
```

It looks like the output is very similar. In both cases, we get the counts by letter. The
output is a dataframe with a column with the letter (`ID`, which was the name of the letter
column in the input dataframe) and a column with the count for that letter. The only 
difference is that the column is generically named `n` when we don't include the 
argument `names = "no_rows"`, but set to `no_rows` when we do include that argument. 

Based on this, it looks like the `names` argument lets us set the name of the column that
gives the counts from the `count` call. If we look at the helpfile for the `count` function
(`?count`), we can confirm this. It says: 

> "`name`: The name of the new column in the output. If omitted, it will default to n. If there's already a column called n, it will use nn. If there's a column called n and nn, it'll use nnn, and so on, adding ns until it gets a new name."

Now let's do the same assessment for the other argument, `.drop = F`. First, let's compare
the output with and without this argument in the call: 

```{r}
# Check count call output when including `.drop = FALSE`
dat %>%
  mutate(ID = factor(ID, levels = letters)) %>%
  count(ID, name = "no_rows", .drop = F)

# Check count call output when excluding `.drop = FALSE`
dat %>%
  mutate(ID = factor(ID, levels = letters)) %>%
  count(ID, name = "no_rows")
```

These outputs look pretty similar, as both give a dataframe that summarizes the count 
by row. However, if we look carefully, we see that one has more rows that the other. 
The output has 26 rows when we include `.drop = F`, but only 22 when we don't. 

We know that there are 26 possible values (the 26 letters) for the thing we're counting, 
so we want a dataframe of counts with a row for each possible value. However, we also
know that there are some possible values that don't show up in the dataframe that we're 
counting. Maybe these are the rows that are missing when we exclude `.drop = FALSE`?
We can check by looking at a letter that we know is missing in the data, "m". Sure enough, 
there's a row for "m" when we include `.drop = F`, with a count of 0, but not a row
when we don't include that argument. Since we want to include all months in our summary
counts, even if there were no animal calls recorded in that month, we will want to 
include `.drop = F` in our own code.

We're now at the final step of the pipeline in the example solution. In this case, 
it's a fairly straightforward call to print out the dataset. This is helpful to demonstrate
the full dataset in this StackOverflow question, but we likely won't need this last
step in our own code function: 

```{r}
dat %>%
  mutate(ID = factor(ID, levels = letters)) %>%
  count(ID, name = "no_rows", .drop = F) %>%
  print.data.frame()
```

## Adapting code

Now, we're ready to adapt this example to our own task. As a reminder, here's our current
function to do this task: 

```{r}
count_monthly_calls <- function(call_data) {
  monthly_calls <- call_data %>% 
    dplyr::count(.wt = call_month) %>% 
    dplyr::rename(month = .wt)
  
  all_months <- tibble::tibble(month = c("January", "February", "March", "April", 
                                         "May", "June", "July", "August", "September", 
                                         "October", "November", "December"), 
                               order = 1:12)
  
  monthly_calls <- dplyr::full_join(monthly_calls, all_months, by = "month") %>% 
    dplyr::mutate(n = if_else(is.na(n), 0, n)) %>% 
    dplyr::arrange(order) %>% 
    dplyr::select(-order)
  
  return(monthly_calls)
}
```

Let's pull out the code within the function and set the input parameter (`call_data`)
to a good example object. This will let us work line-by-line as we adapt the code. 

```{r}
# Rerun the code at the start of this lab if needed to set up the `man_animal_response`
# object

call_data <- man_animal_resp 


```











